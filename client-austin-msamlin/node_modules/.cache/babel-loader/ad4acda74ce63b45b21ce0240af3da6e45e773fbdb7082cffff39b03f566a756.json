{"ast":null,"code":"import { createSlice } from \"@reduxjs/toolkit\";\nconst tasks = createSlice({\n  name: \"tasks\",\n  initialState: [],\n  reducers: {\n    addTasks: (state, action) => {\n      return action.payload;\n    },\n    addTask: (state, action) => {\n      const previousTasks = state;\n      const highestId = previousTasks.length > 0 ? previousTasks.sort((a, b) => b.sortOrder - a.sortOrder)[0] : 0;\n      state.push({\n        id: highestId ? highestId.sortOrder + 1 : highestId,\n        message: action.payload,\n        sortOrder: state.length\n      });\n    },\n    deleteTask: (state, action) => {\n      return state.filter(task => task.id !== action.payload.id);\n    },\n    editTask: (state, action) => {\n      const {\n        id,\n        message\n      } = action.payload;\n      const task = state.find(task => task.id === id);\n      if (task) {\n        task.message = message;\n      } else {\n        return state;\n      }\n    },\n    updateSort: (state, action) => {\n      return action.payload;\n      // const { id, newPosition } = action.payload;\n      // const activeTodo = state.find((task) => task.id === id);\n      // if (activeTodo) {\n      //   const currentPosition = activeTodo.sortOrder;\n      //   if (currentPosition > newPosition) {\n      //     // move sort order up\n      //     state.forEach((task) => {\n      //       if (task.sortOrder >= newPosition && task.sortOrder < currentPosition + 1) {\n      //         task.sortOrder = task.sortOrder + 1; // move down\n      //       } else if (task.sortOrder === currentPosition) {\n      //         task.sortOrder = newPosition; // move to new position\n      //       }\n      //     })\n\n      //     state.splice(newPosition, 0, activeTodo); // insert at new position\n      //     state.splice(currentPosition, 1); // remove from old position\n      //   } else {\n      //     // move sort order down\n      //     state.forEach((task) => {\n      //       if (task.sortOrder <= newPosition && task.sortOrder > currentPosition - 1) {\n      //         task.sortOrder = task.sortOrder - 1; // move up\n      //       } else if (task.sortOrder === currentPosition) {\n      //         task.sortOrder = newPosition; // move to new position\n      //       }\n      //     })\n      //     state.splice(newPosition, 0, activeTodo); // insert at new position\n      //     state.splice(currentPosition, 1); // remove from old position\n      //   }\n      // }\n    }\n  }\n});\nexport const {\n  addTasks,\n  addTask,\n  deleteTask,\n  editTask,\n  updateSort\n} = tasks.actions;\nexport default tasks;","map":{"version":3,"names":["createSlice","tasks","name","initialState","reducers","addTasks","state","action","payload","addTask","previousTasks","highestId","length","sort","a","b","sortOrder","push","id","message","deleteTask","filter","task","editTask","find","updateSort","actions"],"sources":["/Users/anwaukoni/Desktop/Dev/client-austin-msamlin/src/features/task/taskSlice.ts"],"sourcesContent":["import { PayloadAction, createSlice } from \"@reduxjs/toolkit\";\n\nexport interface Task {\n  [x: string]: any;\n  id: number;\n  message: string;\n  sortOrder: number;\n}\n\nconst tasks = createSlice({\n  name: \"tasks\",\n  initialState: [] as Task[],\n  reducers: {\n    addTasks: (state, action: PayloadAction<Task[]>) => {\n      return action.payload;\n    },\n    addTask: (state, action: PayloadAction<string>) => {\n      const previousTasks = state;\n      const highestId = previousTasks.length > 0 ? previousTasks.sort((a,b) => b.sortOrder - a.sortOrder)[0] : 0;\n\n      state.push({\n        id: highestId ? highestId.sortOrder + 1 : highestId ,\n        message: action.payload,\n        sortOrder: state.length,\n      })\n    },\n    deleteTask: (state, action: PayloadAction<{ id: number }>) => {\n      return state.filter((task) => task.id !== action.payload.id)\n    },\n    editTask: (state, action: PayloadAction<{ id: number, message: string }>) => {\n      const { id, message } = action.payload;\n      const task = state.find((task) => task.id === id);\n      if (task) {\n        task.message = message;\n      } else {\n        return state;\n      }\n    },\n    updateSort: (state, action: PayloadAction<Task[]>) => {\n      return action.payload;\n      // const { id, newPosition } = action.payload;\n      // const activeTodo = state.find((task) => task.id === id);\n      // if (activeTodo) {\n      //   const currentPosition = activeTodo.sortOrder;\n      //   if (currentPosition > newPosition) {\n      //     // move sort order up\n      //     state.forEach((task) => {\n      //       if (task.sortOrder >= newPosition && task.sortOrder < currentPosition + 1) {\n      //         task.sortOrder = task.sortOrder + 1; // move down\n      //       } else if (task.sortOrder === currentPosition) {\n      //         task.sortOrder = newPosition; // move to new position\n      //       }\n      //     })\n\n      //     state.splice(newPosition, 0, activeTodo); // insert at new position\n      //     state.splice(currentPosition, 1); // remove from old position\n      //   } else {\n      //     // move sort order down\n      //     state.forEach((task) => {\n      //       if (task.sortOrder <= newPosition && task.sortOrder > currentPosition - 1) {\n      //         task.sortOrder = task.sortOrder - 1; // move up\n      //       } else if (task.sortOrder === currentPosition) {\n      //         task.sortOrder = newPosition; // move to new position\n      //       }\n      //     })\n      //     state.splice(newPosition, 0, activeTodo); // insert at new position\n      //     state.splice(currentPosition, 1); // remove from old position\n      //   }\n      // }\n    }\n  }\n});\n\nexport const { addTasks, addTask, deleteTask, editTask, updateSort } = tasks.actions;\n\nexport default tasks;"],"mappings":"AAAA,SAAwBA,WAAW,QAAQ,kBAAkB;AAS7D,MAAMC,KAAK,GAAGD,WAAW,CAAC;EACxBE,IAAI,EAAE,OAAO;EACbC,YAAY,EAAE,EAAY;EAC1BC,QAAQ,EAAE;IACRC,QAAQ,EAAEA,CAACC,KAAK,EAAEC,MAA6B,KAAK;MAClD,OAAOA,MAAM,CAACC,OAAO;IACvB,CAAC;IACDC,OAAO,EAAEA,CAACH,KAAK,EAAEC,MAA6B,KAAK;MACjD,MAAMG,aAAa,GAAGJ,KAAK;MAC3B,MAAMK,SAAS,GAAGD,aAAa,CAACE,MAAM,GAAG,CAAC,GAAGF,aAAa,CAACG,IAAI,CAAC,CAACC,CAAC,EAACC,CAAC,KAAKA,CAAC,CAACC,SAAS,GAAGF,CAAC,CAACE,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;MAE1GV,KAAK,CAACW,IAAI,CAAC;QACTC,EAAE,EAAEP,SAAS,GAAGA,SAAS,CAACK,SAAS,GAAG,CAAC,GAAGL,SAAS;QACnDQ,OAAO,EAAEZ,MAAM,CAACC,OAAO;QACvBQ,SAAS,EAAEV,KAAK,CAACM;MACnB,CAAC,CAAC;IACJ,CAAC;IACDQ,UAAU,EAAEA,CAACd,KAAK,EAAEC,MAAqC,KAAK;MAC5D,OAAOD,KAAK,CAACe,MAAM,CAAEC,IAAI,IAAKA,IAAI,CAACJ,EAAE,KAAKX,MAAM,CAACC,OAAO,CAACU,EAAE,CAAC;IAC9D,CAAC;IACDK,QAAQ,EAAEA,CAACjB,KAAK,EAAEC,MAAsD,KAAK;MAC3E,MAAM;QAAEW,EAAE;QAAEC;MAAQ,CAAC,GAAGZ,MAAM,CAACC,OAAO;MACtC,MAAMc,IAAI,GAAGhB,KAAK,CAACkB,IAAI,CAAEF,IAAI,IAAKA,IAAI,CAACJ,EAAE,KAAKA,EAAE,CAAC;MACjD,IAAII,IAAI,EAAE;QACRA,IAAI,CAACH,OAAO,GAAGA,OAAO;MACxB,CAAC,MAAM;QACL,OAAOb,KAAK;MACd;IACF,CAAC;IACDmB,UAAU,EAAEA,CAACnB,KAAK,EAAEC,MAA6B,KAAK;MACpD,OAAOA,MAAM,CAACC,OAAO;MACrB;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACF;EACF;AACF,CAAC,CAAC;AAEF,OAAO,MAAM;EAAEH,QAAQ;EAAEI,OAAO;EAAEW,UAAU;EAAEG,QAAQ;EAAEE;AAAW,CAAC,GAAGxB,KAAK,CAACyB,OAAO;AAEpF,eAAezB,KAAK","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}